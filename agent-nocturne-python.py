#!/usr/bin/env python3
"""
Agent IA Nocturne - Version Python
Bot automatique qui filtre et r√©pond aux opportunit√©s freelance
"""

import os
import time
import json
import smtplib
import imaplib
import email
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import openai
from mistralai.client import MistralClient
import schedule
from typing import Dict, List, Optional

# Import du module Telegram
try:
    from telegram_notifications import TelegramNotifier
    TELEGRAM_AVAILABLE = True
except ImportError:
    TELEGRAM_AVAILABLE = False
    print("‚ö†Ô∏è Module Telegram non disponible")

class AgentIANocturne:
    def __init__(self, config: Dict):
        """Initialiser l'Agent IA Nocturne"""
        self.config = config
        
        # Initialiser les clients IA
        self.openai_client = None
        self.mistral_client = None
        
        # Essayer OpenAI d'abord
        if config.get('openai_api_key') and config['openai_api_key'] != "your_openai_api_key_here":
            try:
                self.openai_client = openai.OpenAI(api_key=config['openai_api_key'])
                print("‚úÖ OpenAI configur√©")
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur OpenAI : {e}")
        
        # Fallback sur Mistral
        if config.get('mistral_api_key'):
            try:
                self.mistral_client = MistralClient(api_key=config['mistral_api_key'])
                print("‚úÖ Mistral configur√©")
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur Mistral : {e}")
        
        if not self.openai_client and not self.mistral_client:
            raise Exception("‚ùå Aucun client IA configur√© (OpenAI ou Mistral)")
        
        self.processed_emails = set()
        
        # Configuration email
        self.email_config = config['email']
        self.gmail_user = self.email_config['username']
        self.gmail_password = self.email_config['password']
        
        # Configuration IA
        self.criteria = config['criteria']
        
        # Initialiser Telegram
        self.telegram_notifier = None
        if TELEGRAM_AVAILABLE:
            self.telegram_notifier = TelegramNotifier(config)
            if self.telegram_notifier.enabled:
                print("üì± Telegram configur√©")
            else:
                print("üì± Telegram d√©sactiv√©")
        
        print("ü§ñ Agent IA Nocturne initialis√©")
        print(f"üìß Email surveill√© : {self.gmail_user}")
        print(f"üéØ Crit√®res : {self.criteria}")
    
    def check_new_emails(self, force_all: bool = False) -> List[Dict]:
        """V√©rifier les nouveaux emails"""
        try:
            # Connexion IMAP
            mail = imaplib.IMAP4_SSL("imap.gmail.com")
            mail.login(self.gmail_user, self.gmail_password)
            mail.select("INBOX")
            
            # V√©rifier si c'est la premi√®re ex√©cution ou si on force
            first_run = not os.path.exists("processed_emails.txt")
            
            if first_run or force_all:
                print("üöÄ Analyse des 50 derniers emails...")
                # Rechercher les 50 derniers emails (lus et non lus)
                _, messages = mail.search(None, "ALL")
                email_list = messages[0].split()[-50:]  # 50 derniers
            else:
                # Rechercher seulement les nouveaux emails non lus
                _, messages = mail.search(None, "UNSEEN")
                email_list = messages[0].split()
            
            new_emails = []
            for email_id in email_list:
                _, msg_data = mail.fetch(email_id, "(RFC822)")
                email_body = msg_data[0][1]
                email_message = email.message_from_bytes(email_body)
                
                # Extraire les informations
                subject = email_message["subject"] or "Sans objet"
                sender = email_message["from"]
                date = email_message["date"]
                
                # Extraire le contenu
                body = self.extract_email_body(email_message)
                
                email_info = {
                    "id": email_id.decode(),
                    "subject": subject,
                    "from": sender,
                    "date": date,
                    "body": body,
                    "snippet": body[:500] + "..." if len(body) > 500 else body
                }
                
                new_emails.append(email_info)
                print(f"üìß Nouvel email re√ßu : {subject}")
            
            mail.close()
            mail.logout()
            return new_emails
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la v√©rification des emails : {e}")
            return []
    
    def extract_email_body(self, email_message) -> str:
        """Extraire le contenu du corps de l'email"""
        body = ""
        if email_message.is_multipart():
            for part in email_message.walk():
                if part.get_content_type() == "text/plain":
                    try:
                        body = part.get_payload(decode=True).decode('utf-8', errors='ignore')
                    except:
                        body = part.get_payload(decode=True).decode('latin-1', errors='ignore')
                    break
        else:
            try:
                body = email_message.get_payload(decode=True).decode('utf-8', errors='ignore')
            except:
                body = email_message.get_payload(decode=True).decode('latin-1', errors='ignore')
        return body
    
    def analyze_opportunity(self, email_content: str) -> Dict:
        """Analyser l'opportunit√© avec IA (OpenAI ou Mistral)"""
        prompt = f"""Tu es un assistant IA sp√©cialis√© en tri de missions pour un freelance d√©veloppeur backend Python/API/IA.

Analyse l'opportunit√© suivante (email ou texte brut) et r√©ponds aux 3 questions suivantes :

1. Est-ce que cette mission correspond √† mes crit√®res ?
   - Type : d√©veloppement backend, API, Python, IA
           - Budget minimum : {self.criteria['budget_min']}‚Ç¨
   - Dur√©e max : {self.criteria['duration_max']} jours
   - Langue : {self.criteria['language']}
   - Mots-cl√©s √† √©viter : {', '.join(self.criteria['keywords_to_avoid'])}
   - Pr√©f√©rence : {self.criteria['work_mode']}

2. Note cette mission sur 10 en termes de pertinence pour moi.

3. Si elle est pertinente (note ‚â• {self.criteria['relevance_threshold']}), dis "‚úÖ Mission retenue"
Sinon, dis "‚ùå Mission rejet√©e ‚Äì hors cible".

Voici le texte de l'opportunit√© :
---
{email_content}
---

R√©ponds au format JSON :
{{
  "pertinence": 8,
  "decision": "‚úÖ Mission retenue",
  "raisons": ["Budget suffisant", "Technologies Python/API", "Full remote"],
  "points_attention": ["V√©rifier la dur√©e exacte", "Clarifier les sp√©cifications"]
}}"""

        # Essayer OpenAI d'abord
        if self.openai_client:
            try:
                response = self.openai_client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": prompt}],
                    max_tokens=500,
                    temperature=0.3
                )
                
                result = json.loads(response.choices[0].message.content)
                print(f"üß† Analyse OpenAI termin√©e : {result['decision']} (pertinence: {result['pertinence']}/10)")
                return result
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur OpenAI, essai Mistral : {e}")
        
        # Fallback sur Mistral
        if self.mistral_client:
            try:
                messages = [{"role": "user", "content": prompt}]
                response = self.mistral_client.chat(
                    model="mistral-medium",
                    messages=messages,
                    max_tokens=500,
                    temperature=0.3
                )
                
                result = json.loads(response.choices[0].message.content)
                print(f"üß† Analyse Mistral termin√©e : {result['decision']} (pertinence: {result['pertinence']}/10)")
                return result
                
            except Exception as e:
                print(f"‚ùå Erreur Mistral : {e}")
        
        # Erreur si aucun client ne fonctionne
        print("‚ùå Aucun client IA disponible")
        return {
            "pertinence": 0,
            "decision": "‚ùå Erreur d'analyse",
            "raisons": ["Erreur technique"],
            "points_attention": []
        }
    
    def generate_response(self, email_content: str) -> Dict:
        """G√©n√©rer une r√©ponse automatique avec IA (OpenAI ou Mistral)"""
        prompt = f"""Tu es un assistant personnel freelance sp√©cialis√© en d√©veloppement backend Python/API/IA.

G√©n√®re une r√©ponse professionnelle, aimable et personnalis√©e √† cette mission, en tenant compte des √©l√©ments suivants :

- Tu es freelance sp√©cialis√© en d√©veloppement backend Python, API et IA
- Tu es disponible pour √©changer rapidement
- Tu veux clarifier les attentes du client
- Sois concis, humain, et engageant
- Signature incluse automatiquement

Texte de la mission :
---
{email_content}
---

R√©ponse attendue au format JSON :
{{
  "objet": "Proposition suite √† votre demande de d√©veloppement",
  "message": "Bonjour,\\n\\nMerci pour votre message. Votre projet de d√©veloppement backend/API semble correspondre parfaitement √† mon expertise en Python et IA.\\n\\nJe serais ravi d'√©changer avec vous pour clarifier vos besoins et vous proposer une solution adapt√©e.\\n\\nDisponible pour un appel rapide cette semaine.\\n\\nCordialement,",
  "signature": "{self.config['signature']}"
}}

Le message doit √™tre en fran√ßais, ton professionnel mais accessible, et inclure un appel √† l'action pour un √©change rapide."""

        # Essayer OpenAI d'abord
        if self.openai_client:
            try:
                response = self.openai_client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": prompt}],
                    max_tokens=800,
                    temperature=0.7
                )
                
                result = json.loads(response.choices[0].message.content)
                print(f"‚úçÔ∏è R√©ponse OpenAI g√©n√©r√©e : {result['objet']}")
                return result
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur OpenAI, essai Mistral : {e}")
        
        # Fallback sur Mistral
        if self.mistral_client:
            try:
                messages = [{"role": "user", "content": prompt}]
                response = self.mistral_client.chat(
                    model="mistral-medium",
                    messages=messages,
                    max_tokens=800,
                    temperature=0.7
                )
                
                result = json.loads(response.choices[0].message.content)
                print(f"‚úçÔ∏è R√©ponse Mistral g√©n√©r√©e : {result['objet']}")
                return result
                
            except Exception as e:
                print(f"‚ùå Erreur Mistral : {e}")
        
        # R√©ponse par d√©faut si aucun client ne fonctionne
        print("‚ùå Aucun client IA disponible, r√©ponse par d√©faut")
        return {
            "objet": "R√©ponse automatique",
            "message": "Bonjour,\n\nMerci pour votre message. Je vous r√©pondrai rapidement.\n\nCordialement,",
            "signature": self.config['signature']
        }
    
    def send_email(self, to_email: str, subject: str, body: str, reply_to_id: str = None):
        """Envoyer un email de r√©ponse"""
        try:
            msg = MIMEMultipart()
            # Utiliser l'email Hotmail comme exp√©diteur si configur√©
            from_email = self.config.get('email', {}).get('reply_to', self.gmail_user)
            msg['From'] = from_email
            msg['To'] = to_email
            msg['Subject'] = subject
            
            if reply_to_id:
                msg['In-Reply-To'] = reply_to_id
                msg['References'] = reply_to_id
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            # Connexion SMTP
            server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
            server.login(self.gmail_user, self.gmail_password)
            
            # Envoi
            text = msg.as_string()
            server.sendmail(self.gmail_user, to_email, text)
            server.quit()
            
            print(f"üìß Email envoy√© √† : {to_email}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'envoi : {e}")
            return False
    
    def log_opportunity(self, email_info: Dict, analysis: Dict, action: str):
        """Logger l'opportunit√©"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "email_id": email_info["id"],
            "subject": email_info["subject"],
            "sender": email_info["from"],
            "pertinence": analysis.get("pertinence", 0),
            "decision": analysis.get("decision", "‚ùå Erreur"),
            "action": action,
            "raisons": analysis.get("raisons", [])
        }
        
        # Sauvegarder dans un fichier JSON
        log_file = "opportunities_log.json"
        try:
            if os.path.exists(log_file):
                with open(log_file, 'r', encoding='utf-8') as f:
                    logs = json.load(f)
            else:
                logs = []
            
            logs.append(log_entry)
            
            with open(log_file, 'w', encoding='utf-8') as f:
                json.dump(logs, f, indent=2, ensure_ascii=False)
                
            print(f"üìä Opportunit√© logg√©e : {action}")
            
        except Exception as e:
            print(f"‚ùå Erreur lors du logging : {e}")
    
    def process_email(self, email_info: Dict):
        """Traiter un email"""
        email_id = email_info["id"]
        
        # √âviter les doublons
        if email_id in self.processed_emails:
            return
        
        print(f"\nüîç Traitement de l'email : {email_info['subject']}")
        
        # Analyser l'opportunit√©
        analysis = self.analyze_opportunity(email_info["body"])
        
        # Prendre une d√©cision
        if analysis["decision"] == "‚úÖ Mission retenue":
            print("‚úÖ Mission retenue - G√©n√©ration de r√©ponse...")
            
            # G√©n√©rer la r√©ponse
            response = self.generate_response(email_info["body"])
            
            # Envoyer l'email
            full_body = f"{response['message']}\n\n{response['signature']}"
            success = self.send_email(
                to_email=email_info["from"],
                subject=response["objet"],
                body=full_body,
                reply_to_id=email_id
            )
            
            if success:
                self.log_opportunity(email_info, analysis, "R√©ponse envoy√©e")
            else:
                self.log_opportunity(email_info, analysis, "Erreur envoi")
        else:
            print("‚ùå Mission rejet√©e - Logging...")
            self.log_opportunity(email_info, analysis, "Rejet√©e")
        
        # Marquer comme trait√©
        self.processed_emails.add(email_id)
        
        # Notification Telegram pour les opportunit√©s importantes
        if self.telegram_notifier and self.telegram_notifier.enabled:
            self.telegram_notifier.send_opportunity_alert(email_info, analysis)
    
    def run_once(self, force_all: bool = False):
        """Ex√©cuter une fois"""
        print(f"\nüîÑ V√©rification des emails - {datetime.now().strftime('%H:%M:%S')}")
        new_emails = self.check_new_emails(force_all)
        
        if new_emails:
            print(f"üìß {len(new_emails)} email(s) trouv√©(s)")
            for email_info in new_emails:
                self.process_email(email_info)
        else:
            print("üì≠ Aucun email trouv√©")
    
    def start_monitoring(self, interval_minutes: int = 5):
        """D√©marrer la surveillance continue"""
        print(f"üöÄ D√©marrage de la surveillance - V√©rification toutes les {interval_minutes} minutes")
        print("üåô Agent IA Nocturne actif - Tu dors, il bosse !")
        print("üí° Appuie sur Ctrl+C pour arr√™ter")
        
        # Planifier les v√©rifications
        schedule.every(interval_minutes).minutes.do(self.run_once)
        
        # Planifier le rapport quotidien Telegram
        if self.telegram_notifier and self.telegram_notifier.enabled:
            daily_config = self.telegram_notifier.daily_report
            if daily_config.get("enabled", False):
                report_time = daily_config.get("time", "07:00")
                print(f"üì± Rapport quotidien programm√© √† {report_time}")
                schedule.every().day.at(report_time).do(self.telegram_notifier.send_daily_report)
        
        # Premi√®re v√©rification imm√©diate
        self.run_once()
        
        # Boucle principale
        try:
            while True:
                schedule.run_pending()
                time.sleep(30)  # V√©rifier toutes les 30 secondes
        except KeyboardInterrupt:
            print("\nüõë Arr√™t de l'Agent IA Nocturne")
            print("üìä Statistiques sauvegard√©es dans opportunities_log.json")

def load_config() -> Dict:
    """Charger la configuration"""
    config_file = "agent_config.json"
    
    if os.path.exists(config_file):
        with open(config_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    else:
        # Configuration par d√©faut
        config = {
            "openai_api_key": "your_openai_api_key_here",
            "email": {
                "username": "your_email@gmail.com",
                "password": "your_app_password"
            },
            "criteria": {
                "budget_min": 500,
                "duration_max": 30,
                "language": "fran√ßais",
                "work_mode": "full remote",
                "keywords_to_avoid": ["gratuit", "exposition", "urgent sans budget", "b√©n√©volat"],
                "relevance_threshold": 7
            },
            "signature": "David - D√©veloppeur Backend Python/IA\nwww.davidfreelance.fr\n+33 6 XX XX XX XX"
        }
        
        # Sauvegarder la configuration par d√©faut
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
        
        print(f"üìù Configuration par d√©faut cr√©√©e dans {config_file}")
        print("‚ö†Ô∏è  Modifiez la configuration avant de lancer l'agent")
        return config

def main():
    """Fonction principale"""
    print("ü§ñ Agent IA Nocturne - Version Python")
    print("=" * 50)
    
    # Charger la configuration
    config = load_config()
    
    # V√©rifier la configuration
    if config["openai_api_key"] == "your_openai_api_key_here":
        print("‚ùå Veuillez configurer votre cl√© API OpenAI dans agent_config.json")
        return
    
    if config["email"]["username"] == "your_email@gmail.com":
        print("‚ùå Veuillez configurer vos identifiants email dans agent_config.json")
        return
    
    # Cr√©er et d√©marrer l'agent
    agent = AgentIANocturne(config)
    
    # Mode de fonctionnement
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == "--once":
            print("üîÑ Mode ex√©cution unique")
            agent.run_once()
        elif sys.argv[1] == "--force":
            print("üîÑ Mode ex√©cution unique - analyse forc√©e de tous les emails r√©cents")
            agent.run_once(force_all=True)
        else:
            print("üîÑ Mode surveillance continue")
            agent.start_monitoring()
    else:
        print("üîÑ Mode surveillance continue")
        agent.start_monitoring()

if __name__ == "__main__":
    main() 